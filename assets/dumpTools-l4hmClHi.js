const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/passPostProcess-1MBTaOnh.js","assets/index-DjxoVRif.js","assets/texture-Ioe4Ew16.js","assets/pass.fragment-VE0xtISO.js"])))=>i.map(i=>d[i]);
import{y as I,T as d,x as _,E as m}from"./index-DjxoVRif.js";import{E as x,c as S}from"./passPostProcess-1MBTaOnh.js";import"./texture-Ioe4Ew16.js";let l,c=null;async function R(){return c||(c=new Promise((t,s)=>{let a,n=null;const i={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};_(()=>import("./passPostProcess-1MBTaOnh.js").then(r=>r.t),__vite__mapDeps([0,1,2])).then(({ThinEngine:r})=>{var o;const f=m.Instances.length;try{a=new OffscreenCanvas(100,100),n=new r(a,!1,i)}catch{f<m.Instances.length&&((o=m.Instances.pop())==null||o.dispose()),a=document.createElement("canvas"),n=new r(a,!1,i)}m.Instances.pop(),m.OnEnginesDisposedObservable.add(e=>{n&&e!==n&&!n.isDisposed&&m.Instances.length===0&&E()}),n.getCaps().parallelShaderCompile=void 0;const p=new x(n);_(async()=>{const{passPixelShader:e}=await import("./pass.fragment-VE0xtISO.js");return{passPixelShader:e}},__vite__mapDeps([3,1])).then(({passPixelShader:e})=>{if(!n){s("Engine is not defined");return}const w=new S({engine:n,name:e.name,fragmentShader:e.shader,samplerNames:["textureSampler"]});l={canvas:a,engine:n,renderer:p,wrapper:w},t(l)})}).catch(s)})),await c}async function v(t,s,a,n,i="image/png",r,f){const p=await a.readPixels(0,0,t,s),o=new Uint8Array(p.buffer);D(t,s,o,n,i,r,!0,void 0,f)}async function y(t,s,a,n="image/png",i,r=!1,f=!1,p){return await new Promise(o=>{D(t,s,a,e=>o(e),n,i,r,f,p)})}function D(t,s,a,n,i="image/png",r,f=!1,p=!1,o){R().then(e=>{if(e.engine.setSize(t,s,!0),a instanceof Float32Array){const g=new Uint8Array(a.length);let u=a.length;for(;u--;){const h=a[u];g[u]=Math.round(I(h)*255)}a=g}const w=e.engine.createRawTexture(a,t,s,5,!1,!f,1);e.renderer.setViewport(),e.renderer.applyEffectWrapper(e.wrapper),e.wrapper.effect._bindTexture("textureSampler",w),e.renderer.draw(),p?d.ToBlob(e.canvas,g=>{const u=new FileReader;u.onload=h=>{const A=h.target.result;n&&n(A)},u.readAsArrayBuffer(g)},i,o):d.EncodeScreenshotCanvasData(e.canvas,n,i,r,o),w.dispose()})}function E(){l?(l.wrapper.dispose(),l.renderer.dispose(),l.engine.dispose()):c==null||c.then(t=>{t.wrapper.dispose(),t.renderer.dispose(),t.engine.dispose()}),c=null,l=null}const O={DumpData:D,DumpDataAsync:y,DumpFramebuffer:v,Dispose:E},T=()=>{d.DumpData=D,d.DumpDataAsync=y,d.DumpFramebuffer=v};T();export{E as Dispose,D as DumpData,y as DumpDataAsync,v as DumpFramebuffer,O as DumpTools};
